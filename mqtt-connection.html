<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="mqttjs.html">
<link rel="import" href="mqemitter.html">


<!--
The `<mqtt-connection>` element exposes MQTT connection functionality to the web.
Use one `<mqtt-connection>` element per connection to a mqtt broker.
Currently the element supports `ws` connections.

    <mqtt-connection
        url="ws://127.0.0.1:8080"
        options='{reconnectPeriod: 1000}'>
    </mqtt-connection>


With `auto` set to `true`, the element performs a MQTT.Connect whenever
the element is ready or the connection gets disconnected.

    <mqtt-connection auto></mqtt-connection>

Note: The `options` attribute must be double quoted JSON.

You can disconnect the mqtt-connection explicitly by calling `disconnect` on the
element. And manually connect if `auto` is set to `false` with `connect`

@demo demo/index.html
-->

<dom-module id="mqtt-connection">
  <template>
    <content id="mqttSubscriptions" select="mqtt-subscription"></content>
    <content id="mqttPublications" select="mqtt-publish"></content>
    <content id="content"></content>
  </template>
</dom-module>

<script>

  'use strict';

  Polymer({
    is: 'mqtt-connection',

    /**
     * Fired when a connection is connected.
     *
     * @event mqtt-connection-connected
     */

    /**
     * Fired when a connection is reconnected.
     *
     * @event mqtt-connection-reconnected
     */

    /**
     * Fired when a connection is closed.
     *
     * @event mqtt-connection-close
     */

    /**
     * Fired when a connection is closed.
     *
     * @event mqtt-connection-offline
     */

    /**
     * Fired when a connection error occurs.
     *
     * @event mqtt-connection-error
     */

    /**
     * Fired when a mqtt message is received .
     *
     * @event mqtt-message
     */

    properties: {

      /**
       * Set to `true` to automatically create and connect the mqtt connection.
       */
      auto: {
        type: Boolean,
        readOnly: false,
        value: false,
      },

      /**
       * Set the clean flag to `false` to receive QOS 1 and 2 messages while offline. The messages are delivered if the
       * connection is re-establish with the broker.
       */
      clean: {
        type: Boolean,
        readOnly: false,
        value: true,
      },

      /**
       * Indicates weather the mqtt client is connected to the mqtt broker or not
       */
      connected: {
        type: Boolean,
        readOnly: true,
        notify: true,
        value: false,
        observer: '_connectedChanged',
      },

      /**
       * Indicates weather the mqtt client is currently disconnecting the mqtt connection or not
       */
      disconnecting: {
        type: Boolean,
        readOnly: true,
        notify: true,
        value: false,
      },

      /**
       * The actual MQTT.js client that will be created on the first connect or injected
       * via `<mqtt-connection client="[[client]]">`
       */
      client: {
        type: Object,
        readOnly: false,
        notify: true,
        observer: '_clientChanged',
      },

      /**
       * The prefix of the option.clientId. If the option.clientId is not set a random ID will be generated prefixed
       * with clientIdPrefix
       */
      clientIdPrefix: {
        type: String,
        value: 'mqttjs_',
      },

      /**
       * The options are directly passed to MQTT.js
       * For further documentation see https://github.com/mqttjs/MQTT.js/wiki/connection
       * * options.protocolId :String The mqtt protocolId tha is send to the mqtt broker DEFAULT: "MQTT"
       * * options.protocolVersion :number 4
       * * options.keepalive :number 10
       * * options.clientId :String
       * * options.clean :boolean
       * * options.username :String The username that is user to authenticate the connection with
       * * options.password :String The password that will be used to authenticate the `user` at the mqtt broker
       * * options.will :Object The clients will message that is published from the mqtt broker in behalf of the client
       * if the connection is from the client to the mqtt broker is lost.
       * * options.will.topic :String The topic of the will message of the client eg. "client/"
       * * options.will.qos :number The QOS of the will message of the client
       * * options.will.retain :boolean The retain flag of the will message of the client
       */
      options: {
        type: Object,
        readOnly: false,
        notify: true,
        value: function () {
          return {
            //MQIsdp
            protocolId: "MQTT",
            protocolVersion: 4,
            keepalive: 120,
            reconnectPeriod: 1000,
            clientId: "",
            encoding: "string",
          };
        },
      },

      /**
       * The url of the mqtt broker and can be on the following protocols: 'mqtt', 'mqtts', 'tcp', 'tls', 'ws', 'wss'.
       * E.g ws://localhost:8080
       */
      url: {
        type: String,
        value: '',
      },

      subscriptions: {
        type: Array,
        notify: true,
        readOnly: true,
        value: function () {
          return [];
        },
      },

      publishers: {
        type: Array,
        notify: true,
        readOnly: true,
        value: function () {
          return [];
        },
      },


      /**
       * A reference to the MQEmitter that is used to route messages between the `mqtt-connection` element and the
       * `mqtt-subscription` elements
       *
       * @attribute mqEmitter
       * @type MQEmitter
       * @default `new MQEmitter`
       */
      mqEmitter: {
        type: Object,
        notify: true,
        readOnly: true,
        value: function () {
          return new MQEmitter();
        },
      },
    },

    observers: [],

    listeners: {
      'mqtt-subscription-register': '_subscriptionElementRegistered',
      'mqtt-subscription-unregister': '_subscriptionElementUnregistered',
      'mqtt-publish-register': '_publishElementRegistered',
      'mqtt-publish-unregister': '_publishElementUnregistered',
    },

    _setParentConnectionOnElement: function (element) {
      element._parentConnection = this;
    },

    _subscriptionElementRegistered: function (event) {
      var sub = event.target;
      this._addElementAndRegister("subscriptions", sub);

      if(this.client && this.client.connected) {
        this._createSubscription(sub);
      }
    },

    _publishElementRegistered: function (event) {
      this._addElementAndRegister("publishers", event.target);
    },

    _addElementAndRegister: function (path, element) {
      // adding the element to the array
      this.push(path, element);
      // setting this connection as the parent on the connection
      this._setParentConnectionOnElement(element);
    },

    _subscriptionElementUnregistered: function (event) {
      var sub = event.detail.target;
      if(sub) {
        if(sub.topic && this.client) {
          this.client.unsubscribe(sub.topic);
          this._removeSubFromEmmitter(sub);
        }
        this._unregisterElement("subscriptions", sub);
      }
    },

    _publishElementUnregistered: function (event) {
      this._unregisterElement("publishers", event.detail.target);
    },

    _unregisterElement: function (path, element) {
      this.arrayDelete(path, element);
    },

    _notifySubscriptionChanged: function (element) {
      this._propagateElementChanged(element, "subscriptions");
//      console.log("_notifySubscriptionChanged", event);
//      this.notifyPath("subscriptions.splice", event);
//
//      if(this.subscriptions.length > 0) {
//        var itemsTmp = this.subscriptions;
//        this._setSubscriptions([]);
//        this.async(function () {
//          this.self._setSubscriptions(this.items);
//        }.bind({items: itemsTmp, self: this}));
//      }
    },

    _propagateElementChanged: function(element, arrElementPath){
      // the array property that hold the element that changed
      var arrName = arrElementPath;
      // get the index of the element
      var index = this[arrName].indexOf(element);
      // if the element exists within the array
      if(index >= 0) {
        // get the polymer collection key see:
        // https://github.com/Polymer/polymer/issues/2068
        var polymerPathId = Polymer.Collection.get(this.get(arrName)).getKey(this[arrName][index]);

        // check if the id is valid
        if(polymerPathId >= 0) {

          // get all defined properties of the custom element
          var propertyNames = Object.getOwnPropertyNames(this[arrName][index].properties);

          // iterate over all properties
          for (var i = 0; i < propertyNames.length; i++) {
            // build the path
            var path = [arrName, polymerPathId, propertyNames[i]].join(".");

            // check if the element is an array, then slice needs to get called to actually result in
            // Polymer_propertySetter
            // old !== value => true
            if(Array.isArray(this[arrName][index][propertyNames[i]])) {
              this.notifyPath(path, this[arrName][index][propertyNames[i]].slice());
            }
            // TOOD
            // if the prop is an object each property has to be checked recursively
            // for now use
            // this.set($path, {$prop1: $prop1Old, $prop2: prop2Changed};
            // else if(typeof this[arrName][index][propertyNames[i]] === "object") {
            //
            // }
            else {
              this.notifyPath(path, this[arrName][index][propertyNames[i]]);
            }
          }
        }
      }
    },

    _removeSubFromEmmitter: function (sub) {
      this.mqEmitter.removeListener(sub.topic, sub._handelMessageFunc);
    },

    attached: function () {
      if(this.auto) {
        this.connect();
      }
    },

    _createClient: function () {
      if(mqtt) {
        this.options.clientId = this._generateClientId();
        this.client = mqtt.connect(this.url, this.options);
      } else {
        // failed to load mqtt.js
        // TODO SKO tell the user about this and maybe log environment
        console.error("<mqtt-connection> could not load MQTT.js, pleas check your setup");
      }
    },

    _clientChanged: function (client, old) {
      if(client) {
        client
            .on("reconnect", this._handelReconnect.bind(this))
            .on("connect", this._handelConnected.bind(this))
            .on("close", this._handelClose.bind(this))
            .on("offline", this._handelOffline.bind(this))
            .on("error", this._handelError.bind(this))
            .on("message", this._handelMessage.bind(this))
      }
    },

    _getConnectionStatusOfConnection: function (client) {
      return client ? client.connected : false
    },

    /**
     * Generates a random mqtt client ID
     * @returns {string} the X digit mqtt client ID prefixed with 'mqttjs_'
     * @private
     */
    _generateClientId: function () {
      return this.clientIdPrefix + Math.random().toString(16).substr(2, 8);
    },

    _handelConnected: function () {
      this._setMqttConnected(this._getConnectionStatusOfConnection(this.client));
      this.fire("mqtt-connection-connected", {value: this.connected});
    },

    _handelReconnect: function () {
      this.fire("mqtt-connection-reconnect");
    },

    _handelClose: function () {
      this._setMqttConnected(this._getConnectionStatusOfConnection(this.client));
      this.fire("mqtt-connection-close");
    },

    _handelOffline: function () {
      this._setMqttConnected(this._getConnectionStatusOfConnection(this.client));
      this.fire("mqtt-connection-offline", {value: this.connected});
    },

    _handelError: function () {
      this.fire("mqtt-connection-error");
    },

    _handelMessage: function (topic, message, packet) {
      this.fire("mqtt-message", {'topic': topic, 'message': message, 'packet': packet});
      this.mqEmitter.emit({topic: topic, message: packet})
    },

    _setMqttConnected: function (state) {
      if(typeof state === "boolean") {
        this._setConnected(state);
      }
    },

    _connectedChanged: function (connected, old) {
      if(connected) {
        // after the connection is established we need to subscribe/ resubscribe
        this._subscribeAllSubscriptions();
      } else if(old) {
        this._setUnsubscribedForAllSubscriptions();
      }
    },

    _setUnsubscribedForAllSubscriptions: function () {
      for (var i = 0; i < this.subscriptions.length; i++) {
        this._setUnsubscribedToSubscription(this.subscriptions[i]);
      }
    },

    _setUnsubscribedToSubscription: function (sub) {
      this._removeSubFromEmmitter(sub);
      sub._handelSubscriptionUnsubscribed();
    },

    _subscribeAllSubscriptions: function () {
      var sub;
      for (var i = 0; i < this.subscriptions.length; i++) {
        sub = this.subscriptions[i];
        // subscribe if the subscription is not subscribed
        if(!sub.subscribed) {
          this._createSubscription(sub);
        }
      }
    },

    _createSubscription: function (sub) {
      if(this.client) {
        // subscribe the element at the mqtt-broker
        this.subscribe(sub.topic, sub.qos, sub._handelSubscriptionSubscribedFunc);

        // add the element to the mqEmitter to receive messages on the topic
        this.mqEmitter.on(sub.topic, sub._handelMessageFunc);
      }
    },

    /**
     * connect - connect to an MQTT broker.
     */
    connect: function () {
      // creates the client and automatically connects
      this._createClient();
    },

    /**
     * diconnect - disconnect for the MQTT broker
     */
    disconnect: function () {
      // check if we already have a client before calling end/ disconnect
      if(this.client) {
        this.client.end(true);
      }
    },

    /**
     * Subscribe to an MQTT topic
     * @param topic that the subscription is made to
     * @param opt_qos [0,1,2] with the subscription is made with
     * @param opt_callback an callback that will be executed when the `suback` message is received
     */
    subscribe: function (topic, opt_qos, opt_callback) {
      var opts = {qos: opt_qos || 0};
      if(this.client) {
        this.client.subscribe(topic, opts, opt_callback);
      }
    },

    /**
     * Publish to an MQTT topic
     * @param topic
     * @param message
     * @param opt_qos
     * @param opt_retained
     * @param opt_callback
     */
    publish: function (topic, message, opt_qos, opt_retained, opt_callback) {

      // the optional parameters to the publish
      var opts = {
        // default qos is `0`
        qos: opt_qos || 0,
        // default for retained is `false`
        retain: opt_retained || false
      };

      if(this.client) {
        // actually send the `publish` message to the MQTT broker
        this.client.publish(topic, message, opts, opt_callback);
      }
    },

  });
</script>
